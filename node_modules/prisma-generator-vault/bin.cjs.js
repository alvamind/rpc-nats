#!/usr/bin/env node
'use strict';

var generatorHelper = require('@prisma/generator-helper');
var zod = require('zod');
var internals = require('@prisma/internals');
var fs = require('fs');
var path = require('path');
var Handlebars = require('handlebars');

const configurationSchema = zod.z.object({
    importPath: zod.z.string().optional(),
});

const { parseEnvValue } = internals;

class FileGeneration {
    outputPath;
    static fileName;
    constructor({ outputPath }) {
        this.outputPath = outputPath;
    }
    writeFile(contents) {
        const filePath = path.join(this.outputPath, this.fileName);
        fs.mkdirSync(this.outputPath, { recursive: true });
        fs.writeFileSync(filePath, contents, { flag: "w" });
        return filePath;
    }
}

class FileGenerationWithExports extends FileGeneration {
    static exportConstants;
    get exportAsTypes() {
        return false;
    }
}

class PrismaClientForVaultGeneration extends FileGenerationWithExports {
    importPath;
    static fileName = "PrismaClientForVault.ts";
    static exportConstants = ["Prisma", "PrismaClient", "PrismaPromise"];
    constructor({ outputPath, importPath }) {
        super({ outputPath });
        this.importPath = importPath;
    }
    generate() {
        const contents = `export type { ${this.exportConstants.join(", ")} } from "${this.importPath}"`;
        return [this.writeFile(contents)];
    }
    get fileName() {
        return PrismaClientForVaultGeneration.fileName;
    }
    get exportConstants() {
        return PrismaClientForVaultGeneration.exportConstants;
    }
    get exportAsTypes() {
        return true;
    }
}

class IndexGeneration extends FileGeneration {
    fileExportMap;
    static fileName = "index.ts";
    constructor({ fileExportMap, outputPath }) {
        super({ outputPath });
        this.fileExportMap = fileExportMap;
    }
    generate() {
        const exportLines = Object.keys(this.fileExportMap).map(filePath => {
            const { exportAsTypes, exportConstants } = this.fileExportMap[filePath];
            return `export ${exportAsTypes ? "type " : ""}{ ${exportConstants.join(", ")} } from "./${path.basename(filePath).replace(/\.ts$/, ".js")}"`;
        });
        this.writeFile(exportLines.join("\n"));
        return [this.fileName];
    }
    get fileName() {
        return IndexGeneration.fileName;
    }
}

class TemplatedFileGeneration extends FileGenerationWithExports {
    writeFile() {
        const filePath = path.join(this.outputPath, this.fileName);
        const template = Handlebars.compile(fs.readFileSync(this.templatePath).toString());
        const contents = template(this.templateParameters);
        fs.mkdirSync(this.outputPath, { recursive: true });
        fs.writeFileSync(filePath, contents, { flag: "w" });
        return filePath;
    }
}

class IPrismaDelegateFileGeneration extends TemplatedFileGeneration {
    get fileName() {
        return "IPrismaDelegate.ts";
    }
    get templatePath() {
        return path.join(__dirname, "./IPrismaDelegate.ts.hbs");
    }
    generate() {
        return [this.writeFile()];
    }
    get exportConstants() {
        return ["IPrismaDelegate"];
    }
    get exportAsTypes() {
        return true;
    }
    get templateParameters() {
        return {};
    }
}

class PrismaProxyGeneration extends TemplatedFileGeneration {
    get fileName() {
        return "PrismaProxy.ts";
    }
    get templatePath() {
        return path.join(__dirname, "./PrismaProxy.ts.hbs");
    }
    generate() {
        return [this.writeFile()];
    }
    get exportConstants() {
        return ["PrismaProxy"];
    }
    get templateParameters() {
        return {};
    }
}

class EncapsulatedPrismaRepositoryGeneration extends TemplatedFileGeneration {
    get fileName() {
        return "EncapsulatedPrismaRepository.ts";
    }
    get templatePath() {
        return path.join(__dirname, "./EncapsulatedPrismaRepository.ts.hbs");
    }
    get exportConstants() {
        return ["EncapsulatedPrismaRepository"];
    }
    generate() {
        return [this.writeFile()];
    }
    get templateParameters() {
        return {};
    }
}

class ExposedPrismaRepositoryGeneration extends TemplatedFileGeneration {
    get fileName() {
        return "ExposedPrismaRepository.ts";
    }
    get templatePath() {
        return path.join(__dirname, "./ExposedPrismaRepository.ts.hbs");
    }
    generate() {
        return [this.writeFile()];
    }
    get exportConstants() {
        return ["ExposedPrismaRepository"];
    }
    get templateParameters() {
        return {};
    }
}

const targetProvider = "prisma-client-js";
async function generate(options) {
    const clientGenerator = findClientGenerator(options.otherGenerators);
    if (!clientGenerator) {
        throw new Error(`${targetProvider} is a required generator for this library`);
    }
    const importPath = resolveConfiguredImportPath(options.generator, clientGenerator);
    const outputPath = resolveOutputPath(options.generator.output);
    if (fs.existsSync(outputPath)) {
        fs.rmSync(outputPath, { recursive: true });
    }
    const generators = [
        new PrismaClientForVaultGeneration({ outputPath, importPath }),
        new IPrismaDelegateFileGeneration({ outputPath }),
        new PrismaProxyGeneration({ outputPath }),
        new EncapsulatedPrismaRepositoryGeneration({ outputPath }),
        new ExposedPrismaRepositoryGeneration({ outputPath }),
    ];
    const fileExportMap = generators.reduce((fileManifest, generator) => {
        const filePath = generator.generate().at(0);
        if (!filePath) {
            return new Error("File path not returned from generate");
        }
        return {
            ...fileManifest,
            [filePath]: {
                exportConstants: generator.exportConstants,
                exportAsTypes: generator.exportAsTypes,
            },
        };
    }, {});
    const indexGeneration = new IndexGeneration({ outputPath, fileExportMap });
    return Promise.resolve([...Object.keys(fileExportMap), ...indexGeneration.generate()]);
}
function resolveOutputPath(output) {
    if (!output?.value) {
        throw new Error("No output was specified for prisma-vault");
    }
    if (typeof output.value === "string") {
        return output.value;
    }
    else {
        return parseEnvValue(output);
    }
}
function resolveConfiguredImportPath(generator, clientGenerator) {
    const configParse = configurationSchema.safeParse(generator.config);
    if (!configParse.success) {
        throw new Error("Invalid options for prisma vault");
    }
    const { importPath } = configParse.data;
    if (importPath) {
        return importPath;
    }
    else {
        if (clientGenerator.output && clientGenerator.output.value) {
            return clientGenerator.output.value.replace(/.*node_modules\//, "");
        }
        else {
            return "@prisma/client";
        }
    }
}
function findClientGenerator(otherGenerators) {
    const clientGenerator = otherGenerators.find(generator => {
        return generator.provider.value === targetProvider;
    });
    if (clientGenerator) {
        return clientGenerator;
    }
    else {
        return null;
    }
}

generatorHelper.generatorHandler({
    onManifest: () => ({ prettyName: "Prisma Vault Generator", defaultOutput: "./prisma-vault" }),
    onGenerate: generate,
});
